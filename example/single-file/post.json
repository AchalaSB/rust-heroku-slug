{"code":"static mut module_instance: *mut ArcModule = 0 as *mut ArcModule;\n\n#[repr(C)]\n#[derive(Copy)]\npub struct Rgb {\n  r: u8,\n  g: u8,\n  b: u8,\n}\n\nimpl Rgb {\n  pub fn new(r: u8, g: u8, b: u8) -> Rgb {\n    Rgb {r, g, b}\n  }\n}\n\nimpl Clone for Rgb {\n  fn clone(&self) -> Rgb { *self }\n}\n\nstruct ArcModule {\n  rows: usize,\n  cols: usize,\n  frame_count: usize,\n  fps: usize,\n  is_first: bool,\n  animation: Vec<Rgb>\n}\n\nimpl ArcModule {\n  pub fn create_instance(rows: usize, cols: usize, frame_count: usize, fps: usize, is_first: bool) -> &'static ArcModule {\n    let buffer_size = rows * cols * frame_count;\n    let mut module = ArcModule {\n      rows,\n      cols,\n      frame_count,\n      fps,\n      is_first,\n      animation: Vec::with_capacity(buffer_size)\n    };\n    module.animation.resize(buffer_size, Rgb::new(0, 0, 0));\n    module.animation[0] = Rgb {r: 2, g: 4, b: 10};\n    unsafe { module_instance = Box::into_raw(Box::new(module)) };\n    ArcModule::get_instance()\n  }\n\n  pub fn get_instance<'a>() -> &'a mut ArcModule {\n    unsafe { &mut *module_instance }\n  }\n\n  pub fn get_animation<'a>(&'a mut self) -> &'a mut Vec<Rgb> {\n    &mut self.animation\n  }\n}\n\n#[no_mangle]\npub extern fn init(rows: usize, cols: usize, frame_count: usize, fps: usize, is_first: bool) {\n  ArcModule::create_instance(rows, cols, frame_count, fps, is_first);\n}\n\n#[no_mangle]\npub extern fn getAnimationBuffer() -> *const Rgb {\n  ArcModule::get_instance().get_animation().as_ptr()\n}\n\n#[no_mangle]\npub extern fn apply() {\n  let mut module = ArcModule::get_instance();\n  let rows = module.rows;\n  let cols = module.cols;\n  let ref mut animation = module.get_animation().as_mut_slice();\n  for (index, frame) in animation.chunks_mut(rows * cols).enumerate() {\n    for row in 0 .. rows {\n      for col in 0 .. cols {\n        frame[row * cols + col] = Rgb::new(row as u8 * 6, col as u8 * 6, ((index * 6) % 0xffusize) as u8);\n      }\n    }\n  }\n}\n","opts":[]}